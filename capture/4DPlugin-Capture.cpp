/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-Capture.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : Capture
 #	author : miyako
 #	2019/10/03
 #  
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-Capture.h"

bool request_permission_granted = false;

typedef struct {
    
    NSView *view;
    CALayer *layer;
    
}addSublayerCtx;

void addSublayer(addSublayerCtx *ctx) {

    [ctx->view.layer addSublayer:ctx->layer];/*main thread only*/
    
}

@implementation CaptureMan
- (PA_Picture)copyImage
{
    return PA_CreatePicture((void *)&buf[0], (PA_long32)buf.size());
}

- (void)startRunning
{
    if(isConfigured) {
        [previewLayer setHidden:NO];
        [captureSession startRunning];
    }
}

-(void)stopRunning
{
    if(isConfigured) {
        [captureSession stopRunning];
    }
}

- (void)setPreviewLayerView:(NSView *)view frame:(NSRect)frame flipH:(bool)flipH flipV:(bool)flipV
{
    if(isConfigured) {
        
        if(superLayerView) {
            if(superLayerView != view) {
                [previewLayer removeFromSuperlayer];
            }
        }
        
        if(flipH) {
            
            if (!flipV) {
                [previewLayer setAffineTransform:CGAffineTransformMake(-1, 0, 0, 1, frame.size.width, 0)];
            }else{
                [previewLayer setAffineTransform:CGAffineTransformMake(-1, 0, 0,-1, 0, 0)];
            }
            
        }else{
            if (flipV) {
                [previewLayer setAffineTransform:CGAffineTransformMake( 1, 0, 0,-1, 0,frame.size.height)];
            }else{
                [previewLayer setAffineTransform:CGAffineTransformMake( 1, 0, 0, 1, 0, 0)];
            }
            
        }

        if(superLayerView != view) {
            superLayerView = view;
            addSublayerCtx ctx;
            ctx.layer = previewLayer;
            ctx.view = view;
            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)addSublayer, &ctx);
        }

        [previewLayer setFrame:frame];
    }
}

- (void)updatePreviewLayerFrame:(NSRect)frame flipH:(bool)flipH flipV:(bool)flipV hidden:(bool)hidden
{
    if(isConfigured) {
        
        if(flipH) {
            
            if (!flipV) {
                [previewLayer setAffineTransform:CGAffineTransformMake(-1, 0, 0, 1, frame.size.width, 0)];
            }else{
                [previewLayer setAffineTransform:CGAffineTransformMake(-1, 0, 0,-1, 0, 0)];
            }
            
        }else{
            if (flipV) {
                [previewLayer setAffineTransform:CGAffineTransformMake( 1, 0, 0,-1, 0,frame.size.height)];
            }else{
                [previewLayer setAffineTransform:CGAffineTransformMake( 1, 0, 0, 1, 0, 0)];
            }
            
        }
        
        [previewLayer setHidden:hidden];
        [previewLayer setFrame:frame];
    }
    
}

- (id)init
{
    if(!(self = [super init])) return self;
    
    NSError *error = nil;
    
    captureSession = [[AVCaptureSession alloc]init];
    
    [captureSession beginConfiguration];
    
    videoDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];
    videoInput = [AVCaptureDeviceInput deviceInputWithDevice:videoDevice error:&error];
    
    if (videoInput) {
        if ([captureSession canAddInput:videoInput]) {
            [captureSession addInput:videoInput];
            videoOutput = [[AVCaptureVideoDataOutput alloc]init];
            if (videoOutput) {
                if ([captureSession canAddOutput:videoOutput]) {
                    [captureSession addOutput:videoOutput];
                    
                    imageOutput = [[AVCaptureStillImageOutput alloc]init];
                    if (imageOutput) {
                        
                        if([captureSession canAddOutput:imageOutput])
                        {
                            [captureSession addOutput:imageOutput];
                            previewLayer = [[AVCaptureVideoPreviewLayer alloc]init];
                            
                            /* no combination to emulate 4D resizing (y is pinned to the bottom, not top) */
//                            previewLayer.autoresizingMask = kCALayerWidthSizable|kCALayerHeightSizable;
                            [previewLayer setSession:captureSession];
                            
                            superLayerView = nil;
                            
                            imageCaptured = false;
                            isConfigured = true;
                        }
                    }
                }
            }
        }
    }
    
    [captureSession commitConfiguration];
    
    notificationCenter = [[NSWorkspace sharedWorkspace]notificationCenter];
    
    if (@available(macOS 10.14, *)) {
        [notificationCenter
         addObserver:self
         selector: @selector(onInterrupted:)
         name:AVCaptureSessionWasInterruptedNotification
         object:nil];
        
        [notificationCenter
         addObserver:self
         selector: @selector(onSessionInterruptionEnded:)
         name:AVCaptureSessionInterruptionEndedNotification
         object:nil];
    }
    
    [notificationCenter
     addObserver:self
     selector: @selector(onSessionRuntimeError:)
     name:AVCaptureSessionRuntimeErrorNotification
     object:nil];
    
    [notificationCenter
     addObserver:self
     selector: @selector(onStartRunning:)
     name:AVCaptureSessionDidStartRunningNotification
     object:nil];
    
    [notificationCenter
     addObserver:self
     selector: @selector(onStopRunning:)
     name:AVCaptureSessionDidStopRunningNotification
     object:nil];
    
    [notificationCenter
     addObserver:self
     selector: @selector(onDeviceConnected:)
     name:AVCaptureDeviceWasConnectedNotification
     object:nil];
 
    [notificationCenter
     addObserver:self
     selector: @selector(onDeviceDisconnected:)
     name:AVCaptureDeviceWasDisconnectedNotification
     object:nil];
    
    return self;
}

- (void)onDeviceDisconnected:(NSNotification *)notification
{
    
}
- (void)onDeviceConnected:(NSNotification *)notification
{
    
}
- (void)onStopRunning:(NSNotification *)notification
{
    
}
- (void)onStartRunning:(NSNotification *)notification
{
    
}
- (void)onSessionRuntimeError:(NSNotification *)notification
{
    
}
- (void)onSessionInterruptionEnded:(NSNotification *)notification
{
    
}
- (void)onInterrupted:(NSNotification *)notification
{
    
}

- (bool)isImageReady
{
    return imageCaptured;
}
- (void)captureImage
{
    if(isConfigured) {
        
        if([captureSession isRunning]) {

            imageCaptured = false;
            AVCaptureConnection *connection = [imageOutput connectionWithMediaType:AVMediaTypeVideo];
            
            [imageOutput captureStillImageAsynchronouslyFromConnection:connection
                                                     completionHandler:^( CMSampleBufferRef imageDataSampleBuffer, NSError *error)
             {
                 
                 if(!error)
                 {
                     NSData *data = [AVCaptureStillImageOutput jpegStillImageNSDataRepresentation:imageDataSampleBuffer];
                     if(data) {
                         buf.resize([data length]);
                         [data getBytes:&buf[0] length:[data length]];
                     }
                 }
                 
                 imageCaptured = true;
             }];
        }
    }
}
- (void)dealloc
{
    if(isConfigured) {
        [previewLayer release];
        [videoOutput release];
        [imageOutput release];
    }
    
    [[[NSWorkspace sharedWorkspace] notificationCenter]removeObserver:self];
    
    [captureSession release];
    
    [super dealloc];
}
@end

CaptureMan *captureMan = nil;

void OnStartup()
{
    
}

void OnExit()
{
    if(captureMan)
    {
        [captureMan release];
        captureMan = nil;
    }
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
	try
	{
        switch(selector)
        {
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kCloseProcess :case kDeinitPlugin:
            case kServerDeinitPlugin:
                OnExit();
                break;
                
			// --- Capture
            
			case 1 :
				capture_Request_permisson(params);
				break;

            case 2 :
                capture_Start(params);
                break;
                
            case 3 :
                capture_Stop(params);
                break;
                
            case 4 :
                capture_Image(params);
                break;
                
            case 5 :
                capture_Update(params);
                break;
  
        }

	}
	catch(...)
	{

	}
}

#pragma mark -

NSWindow *getWindow(PA_long32 w) {
    
    //EX_GET_HWND has been fixed in 15R3 to return a NSWindow* on mac 64bit.
    //http://forums.4d.fr/Post/EN/15872830/1/17032044
    
    PA_ulong32 version = (PA_Get4DVersion/*threadSafe*/() & 0x0000FFFF);
    //    int minor = version & 0x000F;
    int r = (version & 0x00F0) >> 4;
    int major = (version & 0xFF00) >> 8;
    if (((major >=0x15) && (r >= 3)) || (major >=0x16))
    {
        return (NSWindow *)PA_GetWindowPtr(reinterpret_cast<NSWindow *>(w));
    }
    
    return 0;
}

void capture_Image(PA_PluginParameters params) {
    
    if(request_permission_granted) {
        if(captureMan)
        {
            [captureMan performSelectorInBackground:@selector(captureImage) withObject:nil];
            
            do {
                PA_YieldAbsolute();
            } while (![captureMan isImageReady]);
            
            PA_Picture p = [captureMan copyImage];
            PA_ReturnPicture(params, p);
        }
    }
}

void capture_Stop(PA_PluginParameters params) {
    
    if(request_permission_granted) {
        if(captureMan)
        {
            [captureMan performSelectorInBackground:@selector(stopRunning) withObject:nil];
        }
    }
}

void capture_Update(PA_PluginParameters params) {
    
    if(request_permission_granted) {
        
        if(captureMan)
        {
            PA_ObjectRef param = PA_GetObjectParameter(params, 1);
            
            if(param) {
                
                PA_long32 x = (PA_long32)ob_get_n(param, L"x");
                PA_long32 y = (PA_long32)ob_get_n(param, L"y");
                PA_long32 width = (PA_long32)ob_get_n(param, L"width");
                PA_long32 height = (PA_long32)ob_get_n(param, L"height");
                
                bool flipV = ob_get_b(param, L"flipV");
                bool flipH = ob_get_b(param, L"flipH");
                bool hidden = ob_get_b(param, L"hidden");
                
                NSRect rect;
                rect.origin.x = x;
                rect.origin.y = y;
                rect.size.width = width;
                rect.size.height = height;
                
                [captureMan updatePreviewLayerFrame:rect flipH:flipH flipV:flipV hidden:hidden];
            }
        }
    }
}

void capture_Start(PA_PluginParameters params) {
    
    if(request_permission_granted) {
        
        PA_ObjectRef param = PA_GetObjectParameter(params, 1);
        
        if(param) {
            
            PA_long32 w = (PA_long32)ob_get_n(param, L"window");
            NSWindow *window = getWindow(w);
            
            PA_long32 x = (PA_long32)ob_get_n(param, L"x");
            PA_long32 y = (PA_long32)ob_get_n(param, L"y");
            PA_long32 width = (PA_long32)ob_get_n(param, L"width");
            PA_long32 height = (PA_long32)ob_get_n(param, L"height");
            
            bool flipV = ob_get_b(param, L"flipV");
            bool flipH = ob_get_b(param, L"flipH");
            
            if(window) {
                
                NSView *contentView = [window contentView];
                
                if(!captureMan)
                {
                    captureMan = [[CaptureMan alloc]init];
                }
                
                NSRect rect;
                rect.origin.x = x;
                rect.origin.y = y;
                rect.size.width = width;
                rect.size.height = height;
                
                [captureMan setPreviewLayerView:contentView frame:rect flipH:flipH flipV:flipV];
                [captureMan performSelectorInBackground:@selector(startRunning) withObject:nil];
            }
        }
    }
}

typedef enum {

    request_permission_unknown = 0,
    request_permission_authorized = 1,
    request_permission_not_determined = 2,
    request_permission_denied = 3,
    request_permission_restricted = 4
    
}request_permission_t;

request_permission_t requestPermission (AVMediaType mediaType) {
    
    if (@available(macOS 10.14, *)) {

        switch ([AVCaptureDevice authorizationStatusForMediaType:mediaType])
        {
            case AVAuthorizationStatusAuthorized:
                request_permission_granted = true;
                return request_permission_authorized;
                break;

            case AVAuthorizationStatusNotDetermined:
                [AVCaptureDevice requestAccessForMediaType:AVMediaTypeVideo completionHandler:^(BOOL granted) {
                    if (granted) {
                        request_permission_granted = true;
                    }
                }];
                return request_permission_not_determined;
                break;

            case AVAuthorizationStatusDenied:
                request_permission_granted = false;
                return request_permission_denied;
                break;
                
            case AVAuthorizationStatusRestricted:
                request_permission_granted = false;
                return request_permission_restricted;
                break;
        }
    }
    
    return request_permission_unknown;
}

/*
 https://stackoverflow.com/questions/18970093/can-an-ios-app-read-its-own-entitlements-at-runtime
 */

void capture_Request_permisson(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    NSBundle *mainBundle = [NSBundle mainBundle];
    if(mainBundle) {
      NSDictionary *infoDictionary = [mainBundle infoDictionary];
        if(infoDictionary) {
            NSString *cameraUsageDescription = [infoDictionary objectForKey:@"NSCameraUsageDescription"];
            if(cameraUsageDescription) {
    
                SecTaskRef sec = SecTaskCreateFromSelf(kCFAllocatorMalloc);
                CFErrorRef err = nil;
                CFBooleanRef boolValue = (CFBooleanRef)SecTaskCopyValueForEntitlement(
                                                                                      SecTaskCreateFromSelf(NULL), CFSTR("com.apple.security.device.camera"), &err);
                if(!err) {
                    
                    if(boolValue) {
                        
                        if(CFBooleanGetValue(boolValue)) {
                            request_permission_t permission = requestPermission(AVMediaTypeVideo);
                            switch (permission) {
                                    
                                case request_permission_authorized:
                                    ob_set_b(status, L"success", true);
                                    break;
                                    
                                case request_permission_denied:
                                    ob_set_b(status, L"success", false);
                                    ob_set_s(status, L"errorMessage", "permission denied");
                                    break;
                                    
                                case request_permission_restricted:
                                    ob_set_b(status, L"success", false);
                                    ob_set_s(status, L"errorMessage", "permission restricted");
                                    break;
                                
                                case request_permission_not_determined:
                                    ob_set_b(status, L"success", false);
                                    ob_set_s(status, L"errorMessage", "permission not determined");
                                    break;
                                    
                                default:
                                    break;
                            }
                        }
                        
                        if(request_permission_granted) {
                            ob_set_b(status, L"success", true);
                        }
                        
                        CFRelease(boolValue);
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "com.apple.security.device.camera is set to false in app entitlement");
                    }
                    
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "com.apple.security.device.camera is missing in app entitlement");
                }
                
                CFRelease(sec);
  
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "NSCameraUsageDescription is missing in app info.plist");
            }
        }else{
            ob_set_b(status, L"success", false);
            ob_set_s(status, L"errorMessage", "failed to locate [mainBundle infoDictionary]");
        }
    }else{
        ob_set_b(status, L"success", false);
        ob_set_s(status, L"errorMessage", "failed to locate [NSBundle mainBundle]");
    }
    
    PA_ReturnObject(params, status);
}

